from __future__ import annotations

from datetime import datetime

from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

from .config import load_settings
from .models import ProgramRecommendation, RecommendationResponse, UserInput
from .services.data_store import get_store
from .services.rag_engine import recommend_programs
from .services.vertex_llm import LLM_SCHEMA_DESCRIPTION, call_vertex_ai_batch

load_dotenv()
settings = load_settings()
store = get_store(settings)

app = FastAPI(title="自治体給付金・補助金 判定AI", version="mvp-0.1")
TARGET_MUNICIPALITY = "港区"

app.add_middleware(
    CORSMiddleware,
    allow_origins=[settings.frontend_origin],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

frontend_root = settings.frontend_dir
dist_dir = frontend_root / "dist"
assets_dir = dist_dir / "assets"

if dist_dir.exists() and assets_dir.exists():
    app.mount("/assets", StaticFiles(directory=assets_dir), name="assets")


@app.get("/")
async def root() -> FileResponse:
    index_path = dist_dir / "index.html" if dist_dir.exists() else frontend_root / "index.html"
    if not index_path.exists():
        raise HTTPException(status_code=404, detail="Frontend not found")
    return FileResponse(index_path)


@app.get("/api/health")
async def health() -> dict:
    return {
        "status": "ok",
        "time": datetime.utcnow().isoformat() + "Z",
        "env": settings.app_env,
    }


@app.get("/api/llm/format")
async def llm_format() -> dict:
    return {"format": LLM_SCHEMA_DESCRIPTION}


@app.post("/api/recommendations", response_model=RecommendationResponse)
async def recommendations(payload: UserInput) -> RecommendationResponse:
    if payload.municipality and payload.municipality != TARGET_MUNICIPALITY:
        raise HTTPException(status_code=400, detail=f"Supported municipality is only {TARGET_MUNICIPALITY}")
    municipality = TARGET_MUNICIPALITY
    programs = store.list_programs(TARGET_MUNICIPALITY)

    base_results = recommend_programs(payload, programs)
    if not settings.use_vertex_ai:
        raise HTTPException(
            status_code=503,
            detail="USE_VERTEX_AI=true is required because reasons/todo/evidence must be generated by LLM.",
        )
    llm_result_map = call_vertex_ai_batch(
        user=payload,
        programs=programs,
        base_recommendations=base_results,
        settings=settings,
    )
    if not llm_result_map:
        raise HTTPException(
            status_code=503,
            detail="Failed to generate reasons/todo/evidence from Vertex AI. Please retry.",
        )

    results: list[ProgramRecommendation] = []
    for item in base_results:
        llm_item = llm_result_map.get(item.program_id)
        
        # AIが回答を生成できなかった場合のフォールバック（不整合を許容して表示を優先）
        if not llm_item:
            from .models import Deadline # インポートが必要なら追加
            results.append(
                ProgramRecommendation(
                    program_id=item.program_id,
                    program_name=item.program_name,
                    eligible=item.eligible,
                    level=item.level,
                    reasons=item.reasons, # ルールエンジンの理由を流用
                    deadline=item.deadline,
                    todo=[],
                    evidence=[],
                )
            )
            continue
            
        results.append(
            ProgramRecommendation(
                program_id=item.program_id,
                program_name=item.program_name,
                eligible=item.eligible,
                level=item.level,
                reasons=llm_item.reasons,
                deadline=llm_item.deadline,
                todo=llm_item.todo,
                evidence=llm_item.evidence,
            )
        )
    return RecommendationResponse(
        municipality=municipality,
        results=results,
        meta={"model": "gcp-vertex-optional", "version": "mvp-0.1"},
    )


@app.get("/api/programs")
async def list_programs(municipality: str | None = None) -> dict:
    selected = TARGET_MUNICIPALITY if municipality is None else municipality
    if selected != TARGET_MUNICIPALITY:
        raise HTTPException(status_code=400, detail=f"Supported municipality is only {TARGET_MUNICIPALITY}")
    programs = store.list_programs(TARGET_MUNICIPALITY)
    return {
        "programs": [
            {
                "program_id": p.program_id,
                "program_name": p.program_name,
                "municipality": p.municipality,
                "summary": p.summary,
                "deadline": p.deadline,
            }
            for p in programs
        ]
    }


@app.get("/api/programs/{program_id}")
async def program_detail(program_id: str) -> dict:
    program = store.get_program(program_id)
    if not program:
        raise HTTPException(status_code=404, detail="Program not found")
    if program.municipality != TARGET_MUNICIPALITY:
        raise HTTPException(status_code=404, detail="Program not found")
    return program.model_dump()
